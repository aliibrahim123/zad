var b=Object.defineProperty;var h=(t,e)=>b(t,"name",{value:e,configurable:!0});const p="zad-cache-v1",R="zad-cache";self.addEventListener("activate",t=>{t.waitUntil((async()=>{for(const e of await self.caches.keys())e.startsWith(R)&&e!==p&&self.caches.delete(e);await self.caches.open(p),await self.clients.claim()})())});self.addEventListener("fetch",t=>{const e=t.request;new URL(e.url).origin!==self.location.origin||e.method!=="GET"||t.respondWith((async()=>{const o=await(await self.caches.open(p)).match(e);return o||(self.navigator.onLine?fetch(e,{headers:{accept:u(e.url)}}):new Response("no internet",{status:404}))})())});self.addEventListener("message",t=>{t.data.type==="cache"&&M(t.data,t.source)});const c=[];async function M(t,e){let i=!1;if(t.action==="query-status"?e.postMessage({type:"cache",action:"query-status",status:c.length===0?"idle":"processing",packs:c.length===0?void 0:c.map(s=>s.pack)}):t.action==="delete-all"?(c.length===0&&(i=!0),c.push({type:"delete-all",pack:""})):t.action==="delete"?(c.length===0&&(i=!0),c.push({type:"delete",pack:t.pack})):t.action==="download"&&(c.length===0&&(i=!0),c.push({type:"download",pack:t.pack})),!i)return;const o=await self.caches.open(p),r=await(await fetch("./internal/contentPacks/info.json")).json();for(;c.length;){const s=c[0],a=s.pack;if(s.type==="delete-all")for(const n of await o.keys())o.delete(n);else if(s.type==="delete")e.postMessage({type:"cache",action:"delete",status:"deleting",pack:a}),await f(250),await x(a),await f(500),e.postMessage({type:"cache",action:"delete",status:"finished",pack:a,nowIdle:c.length===1});else{const n=!!r[a].chunks;e.postMessage({type:"cache",action:"download",status:"started",pack:a,packType:n?"packed":"unpacked"}),await f(250),n?await L(a):await v(a),await f(500),e.postMessage({type:"cache",action:"download",status:"finished",pack:a,nowIdle:c.length===1})}c.shift()}async function v(s){const a=await(await fetch(`./internal/contentPacks/${s}.json`)).json();let n=1;for(const l of a){const d=await fetch(l,{headers:{accept:u(l)}});await o.put(l,d),e.postMessage({type:"cache",action:"download",status:"caching",pack:s,packType:"unpacked",processed:n++,fullCount:a.length})}}h(v,"cacheUnpacked");async function L(s){const a=r[s].chunks;for(let n=0;n<a;n++){const l=await(await fetch(`./internal/contentPacks/${s}_${n}.txt`)).arrayBuffer();e.postMessage({type:"cache",action:"download",status:"fetched",pack:s,packType:"packed",chunk:n+1,chunkCount:a}),await f(100);const d=new Uint8Array(l),E=new DataView(l),U=new TextDecoder,w=23+E.getUint32(19),g=JSON.parse(U.decode(d.slice(23,w))),C=Object.keys(g).length;let k=0;for(const y in g){k++;const[j,P]=g[y],T=d.slice(w+j,w+j+P);await o.put(y,new Response(T,{status:200,headers:{"Content-Type":u(y),"Content-Length":String(T.length),Date:new Date().toUTCString()}})),k%25===0&&(e.postMessage({type:"cache",action:"download",status:"caching",pack:s,packType:"packed",chunk:n+1,chunkCount:a,fileCount:C,processed:k}),await f(100))}e.postMessage({type:"cache",action:"download",status:"finished-chunk",pack:s,packType:"packed",chunk:n+1,chunkCount:a}),await f(100)}}h(L,"cachePacked");async function x(s){const a=await(await fetch(`./internal/contentPacks/${s}.json`)).json();for(const n of S(a,25))await Promise.all(n.map(l=>o.delete(l))),await f(100)}h(x,"handleDelete")}h(M,"handleCache");function f(t){return new Promise(e=>setTimeout(e,t))}h(f,"delay");function S(t,e){const i=[],o=Math.ceil(t.length/e);for(let r=0;r<o;r++)i.push(t.slice(r*e,(r+1)*e));return i}h(S,"chunk");function u(t){return q[t.split(".").at(-1)]||""}h(u,"pathToMine");const q={html:"text/html",css:"text/css",js:"text/javascript",ts:"text/javascript",json:"application/json",txt:"text/plain",ttf:"font/ttf",jpg:"image/jpeg",png:"image/png",svg:"image/svg+xml"},m="zad-cache-v1",D="zad-cache";self.addEventListener("activate",t=>{t.waitUntil((async()=>{for(const e of await self.caches.keys())e.startsWith(D)&&e!==m&&self.caches.delete(e);await self.caches.open(m),await self.clients.claim()})())});self.addEventListener("fetch",t=>{const e=t.request;new URL(e.url).origin!==self.location.origin||e.method!=="GET"||t.respondWith((async()=>{const o=await(await self.caches.open(m)).match(e);return o||(self.navigator.onLine?fetch(e,{headers:{accept:u(e.url)}}):new Response("no internet",{status:404}))})())});self.addEventListener("message",t=>{t.data.type==="cache"&&M(t.data,t.source)});export{m as cacheName};
