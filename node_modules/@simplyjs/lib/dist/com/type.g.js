var be=Object.defineProperty;var p=(r,e)=>be(r,"name",{value:e,configurable:!0});var i=p((r,e)=>{if(typeof r!="string")throw new TypeError(`type: ${e} of type (${r?.constructor?.name}), expected (String)`)},"checkstr"),O=p((r,e="fn")=>{if(typeof r!="function")throw new TypeError(`type: ${e} of type (${r?.constructor?.name}), expected (Function)`)},"checkfn"),y=p((r,e="array")=>{if(!Array.isArray(r))throw new TypeError(`type: ${e} of type (${r?.constructor?.name}), expected (Array)`)},"checkarr"),s=p((r,e="type checker")=>{if(r?.$isTypeChecker!==!0)throw new TypeError(`type: ${e} of type (${r?.constructor?.name}), expected (TypeChecker)`)},"checkChecker");function j(r,e){return s(r),arguments.length===1?t=>r.check(t,"",!1):r.check(e,"",!1)}p(j,"is");function B(r,e,t){return s(r),i(e,"name"),arguments.length===2?o=>r.check(o,e,!0):r.check(t,e,!0)}p(B,"validate");var a=p((r,e,t)=>{throw new TypeError(`${r} of type (${typeof e}), expected (${t})`)},"typeOf"),h=p((r,e,t)=>{throw new TypeError(`${r} of type (${e?.constructor?.name}), expected (${t})`)},"instanceOf"),W={typeOf:a,instanceOf:h};var $={$isTypeChecker:!0,typeName:"any",check:()=>!0};var z={$isTypeChecker:!0,typeName:"never",check(r,e,t){if(t)throw new TypeError(`expected ${e} to never exist`);return!1}};var L=p((r,e=r)=>(i(r,"type"),i(e,"typeName"),{$isTypeChecker:!0,typeName:e,check:(t,o,c)=>typeof t===r||c&&a(o,t,e)}),"typeOf"),F=p((r,e=r?.name)=>(O(r,"type"),i(e,"typeName"),{$isTypeChecker:!0,typeName:e,check:(t,o,c)=>t instanceof r||c&&h(o,t,e)}),"instanceOf");var P={$isTypeChecker:!0,typeName:"string",check:(r,e,t)=>typeof r=="string"||t&&a(e,r,"string")};var R={$isTypeChecker:!0,typeName:"number",check:(r,e,t)=>typeof r=="number"||t&&a(e,r,"number")};var q={$isTypeChecker:!0,typeName:"boolean",check:(r,e,t)=>typeof r=="boolean"||t&&a(e,r,"boolean")};var D={$isTypeChecker:!0,typeName:"void",check:(r,e,t)=>r===void 0||t&&a(e,r,"undefined")};var S={$isTypeChecker:!0,typeName:"null",check:(r,e,t)=>r===null||t&&a(e,r,"null")};var V={$isTypeChecker:!0,typeName:"function",check:(r,e,t)=>typeof r=="function"||t&&a(e,r,"function")};var I={$isTypeChecker:!0,typeName:"symbol",check:(r,e,t)=>typeof r=="symbol"||t&&a(e,r,"symbol")};var M={$isTypeChecker:!0,typeName:"bigint",check:(r,e,t)=>typeof r=="bigint"||t&&a(e,r,"bigint")};var U={$isTypeChecker:!0,typeName:"Date",check:(r,e,t)=>r instanceof Date||t&&h(e,r,"Date")};var G={$isTypeChecker:!0,typeName:"Regexp",check:(r,e,t)=>r instanceof Regexp||t&&h(e,r,"Regexp")};var H={$isTypeChecker:!0,typeName:"Promise",check:(r,e,t)=>r instanceof Promise||t&&h(e,r,"Promise")};var J={$isTypeChecker:!0,typeName:"ArrayBuffer",check:(r,e,t)=>r instanceof ArrayBuffer||t&&h(e,r,"ArrayBuffer")};var K={$isTypeChecker:!0,typeName:"TypedArray",check:(r,e,t)=>r instanceof TypedArray||t&&h(e,r,"TypedArray")};var Oe=p((r,e,t)=>{throw new TypeError(`${r} of value (${e}), expected (${t})`)},"Throw"),x=class{$isTypeChecker=!0;constructor(e,t="unnamed"){this.value=e,i(t,"typeName"),this.typeName=t}check(e,t,o){return Object.is(e,this.value)||o&&Oe(t,e,this.value)}};p(x,"LiteralType");var Q=p((r,e)=>new x(r,e),"literal");var l=class{$isTypeChecker=!0;constructor(e,t=e?.typeName){s(e),this.type=e,i(t,"typeName"),this.typeName=t}check(e,t,o){return e===null||this.type.check(e,t,o)}};p(l,"NullableType");var X=p((r,e)=>new l(r,e),"nullable");var v=class{$isTypeChecker=!0;constructor(e=$,t=e?.typeName+"Array"){s(e,"itemType"),this.itemType=e,i(t,"typeName"),this.typeName=t}check(e,t,o){var c=this.itemType;return(Array.isArray(e)||o&&h(t,e,this.typeName))&&e.every((n,f)=>c.check(n,o&&`${t} at index (${f})`,o))}};p(v,"ArrayType");var Y=p((r,e)=>new v(r,e),"array");var d=class{$isTypeChecker=!0;constructor(e,t=null,o="unnamedTuple"){y(e,"items"),this.items=e.map((c,n)=>{var f="",m;return Array.isArray(c)?[f,m]=c:m=c,i(f,"name"),s(m),[f,m]}),t!==null&&s(t,"restType"),this.rest=t,i(o,"typeName"),this.typeName=o}check(e,t,o){var{items:c,rest:n}=this;if(!Array.isArray(e))return o&&h(t,e,this.typeName);if(!c.every(([m,b],A)=>b.check(e[A],m||o&&`${t} at index (${A})`,o)))return!1;var f=c.length;if(e.length>f){if(n)return e.every((m,b)=>b>=f?n.check(m,o&&`${t} at index (${b})`,o):!0);if(o)throw new TypeError(`${t} of length (${e.length}), expected (${f})`);return!1}return!0}};p(d,"TupleType");var Z=p((r,e,t)=>new d(r,e,t),"tuple");var w=class{$isTypeChecker=!0;constructor(e,t=!1,o="unnamed"){for(let c in e)s(e[c],"shape."+c);this.shape=e,this.strict=t,i(o,"typeName"),this.typeName=o}check(e,t,o){var c=this.shape;for(let n in c)if(!c[n].check(e?.[n],n,o))return!1;if(this.strict&&Object.keys(e).length!==Object.keys(c)){if(o)throw new TypeError(`${t} has keys (${Object.keys(e).join(", ")}), expected (${Object.keys(c).join(", ")})`);return!1}return!0}};p(w,"ObjectType");var _=p((r,e,t)=>new w(r,e,t),"object");var g=class{$isTypeChecker=!0;constructor(e=$,t=e?.typeName+"Record"){s(e,"valueType"),this.valueType=e,i(t,"typeName"),this.typeName=t}check(e,t,o){if(typeof e!="object"&&typeof e!="function"||e===null)return o&&a(t,e,this.typeName);var c=this.valueType;for(let n in e)if(!c.check(e[n],o&&`${t} at key (${n})`,o))return!1;return!0}};p(g,"RecordType");var ee=p((r,e)=>new g(r,e),"record");var u=class{$isTypeChecker=!0;constructor(e,t="unnamedUnion"){y(e,"types"),e.forEach((o,c)=>s(o,`type at index (${c})`)),this.types=e,i(t,"typeName"),this.typeName=t}check(e,t,o){return this.types.every(c=>c.check(e,t,o))}};p(u,"UnionType");var re=p((r,e)=>new u(r,e),"union"),te=p((r,e)=>new u(r,e),"allOf");var k=class{$isTypeChecker=!0;constructor(e,t="unnamedIntersection"){y(e,"types"),e.forEach((o,c)=>s(o,`type at index (${c})`)),this.types=e,i(t,"typeName"),this.typeName=t}check(e,t,o){var c=this.types.some(n=>n.check(e,t,!1));if(!c&&o)throw new TypeError(`${t} of type (${e?.constructor?.name}), expected to be one of (${this.types.map(n=>n.typeName).join(", ")})`);return c}};p(k,"IntersectionType");var oe=p((r,e)=>new k(r,e),"intersection"),ce=p((r,e)=>new k(r,e),"oneOf");var T=class{$isTypeChecker=!0;constructor(e,t,o="unnamedMap"){s(e,"keyType"),this.keyType=e,s(t,"valueType"),this.valueType=t,i(o,"typeName"),this.typeName=o}check(e,t,o){var{keyType:c,valueType:n}=this;return(e instanceof Map||o&&h(t,e,this.typeName))&&Array.from(e.entries()).every(([f,m])=>c.check(f,o&&`key of ${t}`,o)&&n.check(m,o&&`${t} at key (${f})`,o))}};p(T,"MapType");var pe=p((r,e,t)=>new T(r,e,t),"map");var C=class{$isTypeChecker=!0;constructor(e,t=e?.typeName+"Set"){s(e,"itemType"),this.itemType=e,i(t,"typeName"),this.typeName=t}check(e,t,o){var c=this.itemType;return(e instanceof Set||o&&h(t,e,this.typeName))&&Array.from(e).every((n,f)=>c.check(n,o&&`${t} at index (${f})`,o))}};p(C,"SetType");var ne=p((r,e)=>new C(r,e),"set");var N=class{$isTypeChecker=!0;constructor(e,t,o=e&&"decorated"+e.typeName[0].toUpperCase()+e.typeName.slice(1)){s(e),this.type=e,y(t,"decorators"),t.forEach((c,n)=>O(c,`decorator at index (${n})`)),this.decorators=t,i(o,"typeName"),this.typeName=o}check(e,t,o){return this.type.check(e,t,o)&&this.decorators.every(c=>c(e,t,o))}};p(N,"DecoratedType");var ie=p((r,e,t)=>new N(r,e,t),"decorated");var se=p(r=>(e,t,o)=>{var c=e>r;if(!c&&o)throw new TypeError(`${t} of value (${e}), expected greater than (${r})`);return c},"gt"),ae=p(r=>(e,t,o)=>{var c=e<r;if(!c&&o)throw new TypeError(`${t} of value (${e}), expected less than (${r})`);return c},"lt"),he=p(r=>(e,t,o)=>{var c=e>=r;if(!c&&o)throw new TypeError(`${t} of value (${e}), expected greater than or equal (${r})`);return c},"gte"),fe=p(r=>(e,t,o)=>{var c=e<=r;if(!c&&o)throw new TypeError(`${t} of value (${e}), expected less than or equal (${r})`);return c},"lte"),me=p((r,e)=>(t,o,c)=>{var n=t>r&&t<e;if(!n&&c)throw new TypeError(`${o} of value (${t}), expected betweeen (${r}) and (${e})`);return n},"between"),ye=p((r,e,t)=>{var o=Number.isInteger(r);if(!o&&t)throw new TypeError(`${e} of value (${r}), expected integer`);return o},"int"),ue=p((r,e,t)=>{var o=r>0;if(!o&&t)throw new TypeError(`${e} of value (${r}), expected positive`);return o},"positive"),ke=p((r,e,t)=>{var o=r<0;if(!o&&t)throw new TypeError(`${e} of value (${r}), expected negative`);return o},"negative");var $e=p(r=>(e,t,o)=>{var c=e.startsWith(r);if(!c&&o)throw new TypeError(`${t} of value (${e}), expected to start with (${r})`);return c},"startsWith"),xe=p(r=>(e,t,o)=>{var c=e.endsWith(r);if(!c&&o)throw new TypeError(`${t} of value (${e}), expected to end with (${r})`);return c},"endsWith"),le=p(r=>(e,t,o)=>{var c=e.includes(r);if(!c&&o)throw new TypeError(`${t} of value (${e}), expected to contains (${r})`);return c},"contains"),ve=p(r=>(e,t,o)=>{var c=!!e.match(r);if(!c&&o)throw new TypeError(`${t} of value (${e}), expected to match (${r})`);return c},"match");var de=p(r=>(e,t,o)=>{var c=e.length===void 0?e.size:e.length,n=c===r;if(!n&&o)throw new TypeError(`${t} of length (${c}), expected be (${r})`);return n},"ofLength"),we=p(r=>(e,t,o)=>{var c=e.length===void 0?e.size:e.length,n=c<r;if(!n&&o)throw new TypeError(`${t} of length (${c}), expected to be below (${r})`);return n},"ofLengthBelow"),ge=p(r=>(e,t,o)=>{var c=e.length===void 0?e.size:e.length,n=c>r;if(!n&&o)throw new TypeError(`${t} of length (${c}), expected to be above (${r})`);return n},"ofLengthAbove"),Te=p((r,e,t)=>{var o=r.length===void 0?r.size:r.length,c=o===0;if(!c&&t)throw new TypeError(`${e} of length (${o}), expected to be empty`);return c},"empty"),Ce=p((r,e,t)=>{var o=r.length===void 0?r.size:r.length,c=o!==0;if(!c&&t)throw new TypeError(`${e} of length (${o}), expected to be nonempty`);return c},"nonempty"),Ne=p((...r)=>(e,t,o)=>{var c=r.every(n=>e.includes(n));if(!c&&o)throw new TypeError(`expected ${t} to includes (${r.join(", ")})`);return c},"includes");var E={is:j,validate:B,throwers:W,any:$,never:z,typeOf:L,instanceOf:F,union:re,allOf:te,UnionType:u,intersection:oe,oneOf:ce,IntersectionType:k,string:P,number:R,boolean:q,Void:D,Null:S,Function:V,bigint:M,symbol:I,date:U,regexp:G,arrayBuffer:J,typedArray:K,promise:H,literal:Q,LiteralType:x,nullable:X,NullableType:l,array:Y,ArrayType:v,tuple:Z,TupleType:d,object:_,ObjectType:w,record:ee,RecordType:g,map:pe,MapType:T,set:ne,SetType:C,decorated:ie,DecoratedType:N,gt:se,lt:ae,gte:he,lte:fe,between:me,int:ye,positive:ue,negative:ke,startsWith:$e,endsWith:xe,contains:le,match:ve,ofLength:de,ofLengthBelow:we,ofLengthAbove:ge,empty:Te,nonempty:Ce,includes:Ne};globalThis.$type=E;var St=E;export{v as ArrayType,N as DecoratedType,V as Function,k as IntersectionType,x as LiteralType,T as MapType,S as Null,l as NullableType,w as ObjectType,g as RecordType,C as SetType,d as TupleType,u as UnionType,D as Void,te as allOf,$ as any,Y as array,J as arrayBuffer,me as between,M as bigint,q as boolean,le as contains,U as date,ie as decorated,St as default,Te as empty,xe as endsWith,se as gt,he as gte,Ne as includes,F as instanceOf,ye as int,oe as intersection,j as is,Q as literal,ae as lt,fe as lte,pe as map,ve as match,ke as negative,z as never,Ce as nonempty,X as nullable,R as number,_ as object,de as ofLength,ge as ofLengthAbove,we as ofLengthBelow,ce as oneOf,ue as positive,H as promise,ee as record,G as regexp,ne as set,$e as startsWith,P as string,I as symbol,W as throwers,Z as tuple,L as typeOf,K as typedArray,re as union,B as validate};
