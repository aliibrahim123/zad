var X=Object.defineProperty;var i=(e,r)=>X(e,"name",{value:r,configurable:!0});function o(e,r){if(typeof e!="function")throw new TypeError(`obj: ${r} of type (${e?.constructor?.name}), expected (Function)'`)}i(o,"default");var y=i((e,r)=>{o(r),Object.keys(e).forEach(t=>r(e[t],t,e))},"loop"),s=i((e,r)=>{o(r);for(let t in e)r(e[t],t,e)},"loopProto"),O=i((e,r,t=!1,f=!1)=>{o(r);var n;for(Object.getOwnPropertyNames(e).forEach(c=>r(e[c],c,e)),t&&Object.getOwnPropertySymbols(e).forEach(c=>r(e[c],c,e)),f&&(n=Object.getPrototypeOf(e));n;)Object.getOwnPropertyNames(n).forEach(c=>e[c]===n[c]&&r(n[c],c,e)),t&&Object.getOwnPropertySymbols(n).forEach(c=>e[c]===n[c]&&r(n[c],c,e)),n=Object.getPrototypeOf(n)},"loopStrict");var a=i(e=>{if(Array.isArray(e))return e;if(typeof e=="string")return e.split(".");throw new TypeError("obj: path of type ("+e?.constructor?.name+"), expected (Array) or (String)")},"getPath"),x=i((e,r)=>{r=a(r);var t=e,f;for(let n=0;n<r.length;n++){if(f=r[n],t==null)return t;t=t[f]}return t},"get"),h=i((e,r,t)=>{if(r=a(r),r.length!==0){var f=e,n;for(let c=0;c<r.length;c++){if(n=r[c],c===r.length-1)return f[n]=t,t;(f[n]===void 0||f[n]===null)&&(f[n]={}),f=f[n]}}},"set"),g=i((e,r)=>{if(r=a(r),r.length===0)return!1;var t=e,f;for(let n=0;n<r.length;n++){if(f=r[n],n===r.length-1)return delete t[f],!0;if(t[f]===void 0||t[f]===null)return!1;t=t[f]}},"remove"),T=i((e,r,t,...f)=>{if(o(t,"updater"),r=a(r),r.length!==0){var n=e,c;for(let u=0;u<r.length;u++){if(c=r[u],u===r.length-1)return n[c]=t(n[c],r,e,...f),n[c];(n[c]===void 0||n[c]===null)&&(n[c]={}),n=n[c]}}},"update");var P=i((e,r)=>{var t=typeof r=="function"?r:f=>f===r;for(let f in e)if(t(e[f],f,e))return e[f]},"find"),k=i((e,r)=>{var t=typeof r=="function"?r:f=>f===r;for(let f in e)if(t(e[f],f,e))return f},"findKey"),E=i((e,r,t=!1)=>{var f,n=typeof r=="function"?r:c=>c===r;return Object.keys(e).forEach(c=>{n(e[c],c,e)&&(f=t?c:e[c])}),f},"findTyped"),w=i((e,r,t=!1,f=!1)=>{var n=[],c=typeof r=="function"?r:u=>u===r;if(f)Object.keys(e).forEach(u=>{c(e[u],u,e)&&n.push(t?u:e[u])});else for(let u in e)c(e[u],u,e)&&n.push(t?u:e[u]);return n},"findMultiple");var A=i((e,r)=>{o(r,"mapper");var t={};for(let f in e)t[f]=r(e[f],f,e);return t},"map"),$=i((e,r)=>{o(r,"mapper");var t=Object.create(Object.getPrototypeOf(e));return Object.keys(e).forEach(f=>{t[f]=r(e[f],f,e)}),t},"mapTyped"),F=i((e,r)=>{o(r,"mapper");var t={};for(let f in e)t[r(f,e[f],e)]=e[f];return t},"mapKeys"),K=i((e,r)=>{o(r,"mapper");var t=Object.create(Object.getPrototypeOf(e));return Object.keys(e).forEach(f=>{t[r(f,e[f],e)]=e[f]}),t},"mapKeysTyped"),S=i((e,r)=>{o(r,"mapper");var t={};for(let n in e){var f=r(e[n],n,e);t[f[0]]=f[1]}return t},"reshape"),M=i((e,r)=>{o(r,"mapper");var t=Object.create(Object.getPrototypeOf(e));return Object.keys(e).forEach(f=>{var n=r(e[f],f,e);t[n[0]]=n[1]}),t},"reshapeTyped");var N=i((e,r)=>{o(r,"predicate");var t={};for(let f in e)r(e[f],f,e)&&(t[f]=e[f]);return t},"filter"),B=i((e,r)=>{o(r,"predicate");var t=Object.create(Object.getPrototypeOf(e));return Object.keys(e).forEach(f=>{r(e[f],f,e)&&(t[f]=e[f])}),t},"filterTyped"),D=i(e=>{var r={};for(let t in e)e[t]&&(r[t]=e[t]);return r},"clean"),q=i(e=>{var r=Object.create(Object.getPrototypeOf(e));return Object.keys(e).forEach(t=>{e[t]&&(r[t]=e[t])}),r},"cleanTyped");var p=i((e,r,t=!1)=>{if(t&&typeof t!="function")throw new TypeError("obj: copyFn of type ("+t?.constuctor?.name+"), expected (Function)");if(r===void 0)return t?t(e):e;if(typeof e!="object"||e===null||typeof r!="object"||r===null)return r;var f={...e};for(let n in r)f[n]=p(e[n],r[n]);if(t)for(let n in e)r[n]===void 0&&(f[n]=t(e[n]));return f},"mergeDeep"),d=i((e,r,t,f=!1)=>{if(f&&typeof f!="function")throw new TypeError("obj: copyFn of type ("+f?.constuctor?.name+"), expected (Function)");if(r===void 0)return f?f(e):e;if(typeof e!="object"||e===null||typeof r!="object"||r===null||t===void 0)return r;var n={...e};for(let c in r)t[c]!==!1&&(n[c]=d(e[c],r[c],t[c],f));if(f)for(let c in e)r[c]===void 0&&(n[c]=f(e[c]));return n},"mergeByMap");var z=i((e,r,t)=>{o(r,"reducer");for(let f in e)t=r(t,e[f],f,e);return t},"reduce"),C=i((e,r,t)=>(o(r,"reducer"),Object.keys(e).forEach(f=>{t=r(t,e[f],f,e)}),t),"reduceTyped");var G=i((e,r)=>{o(r,"predicate");for(let t in e)if(r(e[t],t,e))return!0;return!1},"some"),H=i((e,r)=>{o(r,"predicate");var t=!1;return Object.keys(e).forEach(f=>{t=t?!0:r(e[f],f,e)}),t},"someTyped"),I=i((e,r)=>{o(r,"predicate");for(let t in e)if(!r(e[t],t,e))return!1;return!0},"every"),J=i((e,r)=>{o(r,"predicate");var t=!0;return Object.keys(e).forEach(f=>{t=t?r(e[f],f,e):!1}),t},"everyTyped");var l=i(e=>{if(!Array.isArray(e))throw new TypeError("obj: props of type ("+e?.constructor?.name+"), expected (Array)")},"checkProps"),L=i((e,r)=>{l(r);var t={};return r.forEach(f=>{t[f]=e[f]}),t},"pick"),Q=i((e,r)=>{l(r);var t=Object.create(Object.getPrototypeOf(e));return r.forEach(f=>{t[f]=e[f]}),t},"pickTyped"),R=i((e,r)=>{l(r);var t={};for(let f in e)r.includes(f)||(t[f]=e[f]);return t},"omit"),U=i((e,r)=>{l(r);var t=Object.create(Object.getPrototypeOf(e));return Object.keys(e).forEach(f=>{r.includes(f)||(t[f]=e[f])}),t},"omitTyped");var V=i(e=>{for(let r in e)typeof e[r]=="function"&&(e[r]=e[r].bind(e));return e},"bindAll"),W=i(e=>(Object.getOwnPropertyNames(r=>{typeof e[r]=="function"&&(e[r]=e[r].bind(e))}),e),"bindAllTyped");var Y=i(()=>{var e=i(r=>function(...t){return r(this,...t)},"handle");for(let r in v)Object.defineProperty(Object.prototype,"$"+r,{value:e(v[r]),enumerable:!1})},"extendNative"),v={loop:y,loopProto:s,loopStrict:O,get:x,set:h,remove:g,update:T,find:P,findKey:k,findTyped:E,findMultiple:w,map:A,mapTyped:$,mapKeys:F,mapKeysTyped:K,reshape:S,reshapeTyped:M,filter:N,filterTyped:B,clean:D,cleanTyped:q,mergeDeep:p,mergeByMap:d,reduce:z,reduceTyped:C,some:G,someTyped:H,every:I,everyTyped:J,pick:L,pickTyped:Q,omit:R,omitTyped:U,bindAll:V,bindAllTyped:W,extendNative:Y},m=v;globalThis.$obj=m;var Ie=m;export{V as bindAll,W as bindAllTyped,D as clean,q as cleanTyped,Ie as default,I as every,J as everyTyped,Y as extendNative,N as filter,B as filterTyped,P as find,k as findKey,w as findMultiple,E as findTyped,x as get,y as loop,s as loopProto,O as loopStrict,A as map,F as mapKeys,K as mapKeysTyped,$ as mapTyped,d as mergeByMap,p as mergeDeep,R as omit,U as omitTyped,L as pick,Q as pickTyped,z as reduce,C as reduceTyped,g as remove,S as reshape,M as reshapeTyped,h as set,G as some,H as someTyped,T as update};
