var z=Object.defineProperty;var c=(e,r)=>z(e,"name",{value:r,configurable:!0});var a=c((e,r="handler")=>{if(typeof e!="function")throw new TypeError(`promise: ${r} of type (${e?.constructor?.name}), expected (Function)`)},"checkfn"),s=c((e,r)=>{if(typeof e!="number")throw new TypeError(`promise: ${r} of type (${e?.constructor?.name}), expected (Number)`);if(!Number.isInteger(e)||e<=0)throw new TypeError(`promise: ${r} is (${e}), expected positive integer`)},"checkpInt"),v=c(e=>{if(!(e instanceof Promise))throw new TypeError(`promise: promise of type (${e?.constructor?.name}), expected (Promise)`)},"checkpromise");var y=c((e,r,t)=>(v(e),a(t,"catcher"),e.catch(o=>o instanceof r&&t(o))),"catchOfType"),w=c((e,r)=>(v(e),a(r),e.then(t=>(r(t),t))),"tap"),k=c((e,r)=>(a(e),s(r,"delay"),new Promise((t,o)=>setTimeout(()=>e(t,o),r))),"delay");var d=c(()=>{var e,r,t=new Promise((o,n)=>{e=o,r=n});return{promise:t,resolve:e,reject:r}},"extracted"),T=c(e=>{checkhandler(e);var r=!1,t=new Promise((o,n)=>{e(p=>r||o(p),p=>r||n(p))});return{promise:t,cancel:()=>r=!0}},"cancelable"),E=c(e=>(a(e,"fn"),(...r)=>new Promise((t,o)=>{e(...r,(n,p)=>{n?o(n):t(p)})})),"promisify");var h=c(e=>{if(!Array.isArray(e))throw new TypeError("promise: array of type ("+e?.constructor?.name+"), expected (Array)")},"checkarr"),g=c((e,r)=>(a(r),h(e),e.reduce((t,o,n)=>t.then(()=>new Promise((p,i)=>r(o,p,i,n,e))),Promise.resolve())),"each"),$=c((e,r)=>(a(r),h(e),Promise.all(e.map((t,o)=>new Promise((n,p)=>r(t,n,p,o,e))))),"map"),A=c((e,r)=>(a(r),h(e),e.reduce((t,o,n)=>t.then(p=>new Promise((i,f)=>r(o,i,f,n,e)).then(i=>(p.push(i),p))),Promise.resolve([]))),"mapSeries"),I=c((e,r)=>(a(r),h(e),Promise.all(e.map((t,o)=>new Promise((n,p)=>r(t,n,p,o,e)))).then(t=>e.filter((o,n)=>t[n]))),"filter"),B=c((e,r,t)=>(a(r),h(e),e.reduce((o,n,p)=>o.then(i=>new Promise((f,m)=>r(i,n,f,m,p,e))),Promise.resolve(t))),"reduce");var O=c(e=>{if(!Array.isArray(e))throw new TypeError("promise: promises of type ("+e?.constructor?.name+"), expected (Array)");e.forEach((r,t)=>{if(!(r instanceof Promise))throw new TypeError("promise: promise at index ("+t+") of type ("+r?.constructor?.name+"), expected (Array)")})},"checkpromises"),F=c((e,r)=>{if(O(e),s(r,"count"),e.length<r)throw new TypeError("promise: promises length ("+e.length+") less than count ("+r+")");return new Promise((t,o)=>{var n=[],p=[],i=c(()=>{n.length===r&&t(n),e.length-p.length<r&&o(p)},"check");e.forEach(f=>f.then(m=>n.push(m)&&i()).catch(m=>p.push(m)&&i()))})},"some"),N=c(e=>new Promise((r,t)=>{var o={...e},n=[];for(let p in e)e[p]instanceof Promise&&n.push(e[p].then(i=>o[p]=i));Promise.all(n).then(()=>r(o)).catch(t)}),"props"),D=c((...e)=>(Array.isArray(e[0])&&(e=e[0]),O(e),new Promise((r,t)=>{var o=0;e.forEach(n=>n.then(p=>{o++,o===e.length&&r(p)},p=>{o++,o===e.length&&t(p)}))})),"last");var u=c((e,r,t,o)=>{a(e),s(r,"limit");var n=0,p=c((i,f,m,x)=>{n++,o(i,f)?n===r?x("max attempts reached"):setTimeout(()=>e(l=>p(l,!1,m,x),l=>p(l,!0,m,x)),t(n)):m(i)},"handle");return new Promise((i,f)=>e(m=>p(m,!1,i,f),m=>p(m,!0,i,f)))},"handle"),L=c((e,r,t=0,o=()=>!0)=>(s(t,"delay"),u(e,r,()=>t,o)),"retry"),S=c((e,r,t,o,n=()=>!0)=>(s(t,"initDelay"),s(o,"delayMultiplier"),u(e,r,p=>t+p*o,n)),"retryLinearBackoff"),b=c((e,r,t,o=()=>!0)=>(s(t,"delayMultiplier"),u(e,r,n=>(1<<n)*t,o)),"retryExponentialBackoff"),q=c((e,r,t,o=()=>!0)=>(a(t,"delayFn"),u(e,r,t,o)),"retryDelayFn");var C=c(()=>Object.assign(Promise.prototype,{$catchOfType(e,r){return y(this,e,r)},$tap(e){return w(this,e)}}),"extendNative"),P={catchOfType:y,tap:w,delay:k,extracted:d,cancelable:T,promisify:E,map:$,mapSeries:A,filter:I,reduce:B,each:g,some:F,props:N,last:D,retry:L,retryLinearBackoff:S,retryExponentialBackoff:b,retryDelayFn:q,extendNative:C};globalThis.$promise=P;var he=P;export{T as cancelable,y as catchOfType,he as default,k as delay,g as each,C as extendNative,d as extracted,I as filter,D as last,$ as map,A as mapSeries,E as promisify,N as props,B as reduce,L as retry,q as retryDelayFn,b as retryExponentialBackoff,S as retryLinearBackoff,F as some,w as tap};
